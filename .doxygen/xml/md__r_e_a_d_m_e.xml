<?xml version='1.0' encoding='UTF-8' standalone='no'?>
<doxygen xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="compound.xsd" version="1.12.0" xml:lang="en-US">
  <compounddef id="md__r_e_a_d_m_e" kind="page">
    <compoundname>md__r_e_a_d_m_e</compoundname>
    <title>Local Network Communication Simulation System</title>
    <briefdescription>
    </briefdescription>
    <detaileddescription>
<para><anchor id="md__r_e_a_d_m_e_1autotoc_md187"/></para>
<para>This project is divided into <computeroutput>physical simulation layer</computeroutput> and <computeroutput>protocol layer</computeroutput>.</para>
<para>For detailed information, please refer to the <ulink url="https://github.com/XLxiaoliaoGmail/Simulated-Local-Area-Network-Communication-System/blob/master/doc/API.md">API documentation</ulink>.</para>
<sect1 id="md__r_e_a_d_m_e_1autotoc_md188">
<title>physical simulation layer</title><para>The physical simulation layer simulates the key behaviors of lower-layer firmware of the 802.15.4, which is a widely used protocol for low-rate wireless personal area networks (LR-WPANs) , including message sending and listening, channel occupancy and waiting, and communication interference. It also creates a virtual experimental environment that allows these devices to operate in the time dimension.</para>
<para>The following diagram shows how the simulation environment operates.</para>
<para><image type="html" name="https://github.com/user-attachments/assets/054032d2-3df9-44ad-b0d3-0c4a3676767f" inline="yes"></image>
</para>
</sect1>
<sect1 id="md__r_e_a_d_m_e_1autotoc_md189">
<title>protocol layer</title><para>The protocol layer simulates the behavior of real devices. Users can easily use the protocol layer&apos;s API directly without needing to worry about the underlying implementation.</para>
<para>The following diagram demonstrates the class relationship between the &quot;communication protocol specialized device&quot; and the &quot;underlying physical device&quot;.</para>
<para><image type="html" name="https://github.com/user-attachments/assets/dc4a513e-795a-40a1-a022-533d12ee1d00" inline="yes"></image>
</para>
</sect1>
<sect1 id="md__r_e_a_d_m_e_1autotoc_md190">
<title>demo (main function)</title><para>The main function demonstrates an instance of this system. In this experiment, a server, 10 robots, and 10 charging stations are started at the 10th tick. Robots and charging stations log in to the server using keys after startup. At the 5000th tick, a &quot;robot requests charging&quot; event occurs. Each device&apos;s behavior is logged in detail to the console, allowing the operator to see what happens and make further optimizations and adjustments. The output\main.exe is the compiled file. You can open it if you trust it.</para>
<para>It simulated the following events:</para>
<para><orderedlist>
<listitem><para>Due to some reasons, the robot needs to charge and sends a request to the server.</para>
</listitem><listitem><para>The server finds an available charging station and sends the communication address, location, and handshake key to the robot, then sends the handshake key to the charging station.</para>
</listitem><listitem><para>The robot uses the key to handshake with the charging station.</para>
</listitem><listitem><para>The robot starts charging.</para>
</listitem><listitem><para>During charging, the robot and the charging station maintain a keep-alive connection.</para>
</listitem><listitem><para>Charging is completed, and the keep-alive connection is canceled.</para>
</listitem><listitem><para>The charging station returns to idle status.</para>
</listitem></orderedlist>
</para>
<para>The following diagram delays the process of this experiment.</para>
<para><image type="html" name="https://github.com/user-attachments/assets/b7969871-1b95-48f9-a388-333767f2f0a6" inline="yes"></image>
</para>
</sect1>
<sect1 id="md__r_e_a_d_m_e_1autotoc_md191">
<title>Overview - Physical Simulation Layer</title><sect2 id="md__r_e_a_d_m_e_1autotoc_md192">
<title>Environment</title><para>The <computeroutput><ref refid="class_environment" kindref="compound">Environment</ref></computeroutput> class simulates the physical environment and basic simulation functions. Time in the simulation is measured in ticks, and certain events may be triggered at specific ticks to achieve the simulation effect.</para>
</sect2>
<sect2 id="md__r_e_a_d_m_e_1autotoc_md193">
<title>SimEvent</title><para><computeroutput><ref refid="class_sim_event" kindref="compound">SimEvent</ref></computeroutput> is an auxiliary class for <computeroutput><ref refid="class_environment" kindref="compound">Environment</ref></computeroutput>, recording events that occur at specific times and triggering them when the simulation reaches that moment. This class facilitates setting up events in the simulation environment.</para>
</sect2>
<sect2 id="md__r_e_a_d_m_e_1autotoc_md194">
<title>Channel</title><para>The <computeroutput><ref refid="class_channel" kindref="compound">Channel</ref></computeroutput> class simulates the behavior of various channels in the environment, including channel occupation and signal interference. An <computeroutput><ref refid="class_environment" kindref="compound">Environment</ref></computeroutput> instance may contain multiple <computeroutput>Channels</computeroutput>. When a <computeroutput><ref refid="class_device" kindref="compound">Device</ref></computeroutput> sends a message to a <computeroutput><ref refid="class_channel" kindref="compound">Channel</ref></computeroutput> and the message is not interfered with, it will be broadcast to all <computeroutput>Devices</computeroutput> listening to that <computeroutput><ref refid="class_channel" kindref="compound">Channel</ref></computeroutput>.</para>
</sect2>
<sect2 id="md__r_e_a_d_m_e_1autotoc_md195">
<title>Device</title><para>The <computeroutput><ref refid="class_device" kindref="compound">Device</ref></computeroutput> class simulates the physical implementation of devices, each with its own address. Devices can send messages to a <computeroutput><ref refid="class_channel" kindref="compound">Channel</ref></computeroutput> (sending messages consumes ticks, during which the device is busy and the channel is occupied). Devices also implement basic channel occupation-waiting mechanisms and message queue mechanisms (if multiple message sending requests occur in a short time, messages are stored in a queue and sent sequentially). Devices can listen to messages on a <computeroutput><ref refid="class_channel" kindref="compound">Channel</ref></computeroutput> (each device can only listen to one channel at a time).</para>
<para>The following diagram demonstrates how a device sends data to the channel, which is then broadcast to each device listening to the channel.</para>
<para><image type="html" name="https://github.com/user-attachments/assets/e6367711-5d83-47f0-8371-5ba8fea9627c" inline="yes"></image>
</para>
</sect2>
</sect1>
<sect1 id="md__r_e_a_d_m_e_1autotoc_md196">
<title>Overview - Protocol Implementation Layer</title><sect2 id="md__r_e_a_d_m_e_1autotoc_md197">
<title>ProtocolDevice</title><para><computeroutput><ref refid="class_protocol_device" kindref="compound">ProtocolDevice</ref></computeroutput> extends <computeroutput><ref refid="class_device" kindref="compound">Device</ref></computeroutput> by adding basic protocol functionalities. Each message includes a type and payload, and received broadcast messages can be processed, such as filtering out messages not intended for the device, registering message handlers, sending messages, and listening for callbacks.</para>
</sect2>
<sect2 id="md__r_e_a_d_m_e_1autotoc_md198">
<title>Server</title><para>The <computeroutput><ref refid="class_server" kindref="compound">Server</ref></computeroutput> class is a specific implementation of <computeroutput><ref refid="class_protocol_device" kindref="compound">ProtocolDevice</ref></computeroutput>, representing a central server device. It handles server-related behaviors, such as listening for login requests and handling robot charging requests. The server can manage all devices, which prioritize communication with the server unless authorized otherwise. The server does not manage any devices at startup; devices must log in to the server to be managed. Each device has a login key, and only devices with valid keys are added to the specific device pool.</para>
</sect2>
<sect2 id="md__r_e_a_d_m_e_1autotoc_md199">
<title>Robot</title><para>The <computeroutput><ref refid="class_robot" kindref="compound">Robot</ref></computeroutput> class is a specific implementation of <computeroutput><ref refid="class_protocol_device" kindref="compound">ProtocolDevice</ref></computeroutput>, representing a robot device. It implements behaviors related to robots, such as logging in and requesting charging.</para>
</sect2>
<sect2 id="md__r_e_a_d_m_e_1autotoc_md200">
<title>Station</title><para>The <computeroutput><ref refid="class_station" kindref="compound">Station</ref></computeroutput> class is a specific implementation of <computeroutput><ref refid="class_protocol_device" kindref="compound">ProtocolDevice</ref></computeroutput>, representing a charging station device. It implements behaviors related to charging stations, such as logging in and handling charging requests.</para>
<para>For detailed information, please refer to the <ulink url="https://github.com/XLxiaoliaoGmail/Simulated-Local-Area-Network-Communication-System/blob/master/doc/API.md">API documentation</ulink>. </para>
</sect2>
</sect1>
    </detaileddescription>
    <location file="README.md"/>
  </compounddef>
</doxygen>
