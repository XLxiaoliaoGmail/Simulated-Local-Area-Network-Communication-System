<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.12.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Simulated-Local-Area-Network-Communication-System: API</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">Simulated-Local-Area-Network-Communication-System
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.12.0 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() { codefold.init(0); });
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search',true);
  $(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){initNavTree('md_doc_2_a_p_i.html',''); initResizable(true); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div><div class="header">
  <div class="headertitle"><div class="title">API</div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p><a class="anchor" id="autotoc_md0"></a></p>
<p>This project simulates a local network communication system, divided into two main layers: the <b>Physical Simulation Layer</b> and the <b>Protocol Implementation Layer</b>.</p>
<h1><a class="anchor" id="autotoc_md1"></a>
Environment Class</h1>
<p>The <code><a class="el" href="class_environment.html">Environment</a></code> class simulates the physical environment for a local network communication system. It manages devices, channels, and simulation events while keeping track of the simulation time.</p>
<h2><a class="anchor" id="autotoc_md2"></a>
Attributes</h2>
<ul>
<li><b><code>running</code></b> (<code>bool</code>): Indicates whether the simulation is currently running. Default is <code>false</code>.</li>
<li><b><code>devices</code></b> (<code>std::vector&lt;Device*&gt;</code>): A collection of pointers to <code><a class="el" href="class_device.html">Device</a></code> objects participating in the simulation.</li>
<li><b><code>time</code></b> (<code>TIME_TYPEDEF</code>): Tracks the current simulation time in ticks.</li>
<li><b><code>eventsAtCertainTick</code></b> (<code>std::unordered_map&lt;TIME_TYPEDEF, std::vector&lt;SimEvent*&gt;&gt;</code>): Maps specific simulation ticks to lists of scheduled events (<code><a class="el" href="class_sim_event.html">SimEvent</a></code>).</li>
<li><b><code>channels</code></b> (<code><a class="el" href="class_channel.html" title="Represents a communication channel between devices.">Channel</a>[CHANNEL_COUNTS]</code>): An array of <code><a class="el" href="class_channel.html" title="Represents a communication channel between devices.">Channel</a></code> objects, representing communication channels available in the environment.</li>
</ul>
<h2><a class="anchor" id="autotoc_md3"></a>
Methods</h2>
<h3><a class="anchor" id="autotoc_md4"></a>
Constructor</h3>
<ul>
<li><b><code>explicit <a class="el" href="class_environment.html">Environment()</a></code></b><ul>
<li>Initializes an <code><a class="el" href="class_environment.html">Environment</a></code> object with <code>running</code> set to <code>false</code> and <code>time</code> set to <code>0</code>.</li>
</ul>
</li>
</ul>
<h3><a class="anchor" id="autotoc_md5"></a>
Public Methods</h3>
<ul>
<li><b><code>void addDevice(Device* d)</code></b><ul>
<li>Adds a device to the simulation environment.</li>
<li><b>Parameters:</b><ul>
<li><code>d</code>: A pointer to the <code><a class="el" href="class_device.html">Device</a></code> object to be added.</li>
</ul>
</li>
</ul>
</li>
<li><b><code>void broadcast(const Message* msg, CHANNEL_INDEX_TYPEDEF channelIndex, TIME_TYPEDEF sendingTime)</code></b><ul>
<li>Broadcasts a message to all devices listening to the specified channel.</li>
<li><b>Parameters:</b><ul>
<li><code>msg</code>: A pointer to the <code><a class="el" href="class_message.html">Message</a></code> to be broadcasted.</li>
<li><code>channelIndex</code>: The index of the channel through which the message is broadcasted.</li>
<li><code>sendingTime</code>: The time at which the message is sent.</li>
</ul>
</li>
</ul>
</li>
<li><b><code>void update()</code></b><ul>
<li>Advances the simulation by processing events and updating the environment's state.</li>
</ul>
</li>
<li><b><code>SimEvent* registerEvent(TIME_TYPEDEF tick, std::function&lt;void()&gt; callback)</code></b><ul>
<li>Registers a new event to be executed at a specific simulation tick.</li>
<li><b>Parameters:</b><ul>
<li><code>tick</code>: The simulation time (in ticks) when the event will occur.</li>
<li><code>callback</code>: A function to be executed when the event triggers.</li>
</ul>
</li>
<li><b>Returns:</b> A pointer to the registered <code><a class="el" href="class_sim_event.html">SimEvent</a></code>.</li>
</ul>
</li>
<li><b><code>SimEvent* delayEvent(TIME_TYPEDEF delayTick, std::function&lt;void()&gt; callback)</code></b><ul>
<li>Schedules an event to occur after a specified delay from the current simulation time.</li>
<li><b>Parameters:</b><ul>
<li><code>delayTick</code>: The delay (in ticks) from the current simulation time.</li>
<li><code>callback</code>: A function to be executed when the event triggers.</li>
</ul>
</li>
<li><b>Returns:</b> A pointer to the scheduled <code><a class="el" href="class_sim_event.html">SimEvent</a></code>.</li>
</ul>
</li>
<li><b><code>void log(const std::string&amp; log)</code></b><ul>
<li>Logs a message for debugging or output purposes.</li>
<li><b>Parameters:</b><ul>
<li><code>log</code>: A string containing the message to log.</li>
</ul>
</li>
</ul>
</li>
<li><b><code>TIME_TYPEDEF getTime() const</code></b><ul>
<li>Retrieves the current simulation time.</li>
<li><b>Returns:</b> The current time as a <code>TIME_TYPEDEF</code>.</li>
</ul>
</li>
<li><b><code>void endAt(TIME_TYPEDEF time)</code></b><ul>
<li>Sets the simulation to stop at a specified tick.</li>
<li><b>Parameters:</b><ul>
<li><code>time</code>: The tick at which the simulation will end.</li>
</ul>
</li>
</ul>
</li>
<li><b><code>void stopRun()</code></b><ul>
<li>Immediately stops the simulation from running.</li>
</ul>
</li>
<li><b><code>void run()</code></b><ul>
<li>Starts the simulation and processes events until manually stopped or the end time is reached.</li>
</ul>
</li>
<li><b><code>Channel* getChannels()</code></b><ul>
<li>Retrieves a pointer to the array of channels in the environment.</li>
<li><b>Returns:</b> A pointer to the <code><a class="el" href="class_channel.html" title="Represents a communication channel between devices.">Channel</a></code> array.</li>
</ul>
</li>
<li><b><code>void error(std::string s)</code></b><ul>
<li>Throws a runtime error with a specified message.</li>
<li><b>Parameters:</b><ul>
<li><code>s</code>: A string containing the error message.</li>
</ul>
</li>
</ul>
</li>
</ul>
<h1><a class="anchor" id="autotoc_md6"></a>
SimEvent Class</h1>
<p>The <code><a class="el" href="class_sim_event.html">SimEvent</a></code> class represents an event scheduled to occur at a specific time during the simulation. It supports chaining events and executing callback functions.</p>
<h2><a class="anchor" id="autotoc_md7"></a>
Attributes</h2>
<ul>
<li><b><code>emitTick</code></b> (<code>TIME_TYPEDEF</code>): The simulation tick at which the event will be triggered.</li>
<li><b><code>callback</code></b> (<code>std::function&lt;void()&gt;</code>): A function to execute when the event is triggered.</li>
<li><b><code>en</code></b> (<code>Environment*</code>): A pointer to the <code><a class="el" href="class_environment.html">Environment</a></code> instance where the event is scheduled.</li>
</ul>
<h2><a class="anchor" id="autotoc_md8"></a>
Methods</h2>
<h3><a class="anchor" id="autotoc_md9"></a>
Constructor</h3>
<ul>
<li><b><code>explicit <a class="el" href="class_sim_event.html">SimEvent</a>(Environment* en, TIME_TYPEDEF emitTick, std::function&lt;void()&gt; callback)</code></b><ul>
<li>Creates a new <code><a class="el" href="class_sim_event.html">SimEvent</a></code> object.</li>
<li><b>Parameters:</b><ul>
<li><code>en</code>: A pointer to the <code><a class="el" href="class_environment.html">Environment</a></code> instance in which the event is scheduled.</li>
<li><code>emitTick</code>: The simulation tick at which the event will be triggered.</li>
<li><code>callback</code>: A function to execute when the event is triggered.</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3><a class="anchor" id="autotoc_md10"></a>
Public Methods</h3>
<ul>
<li><b><code>SimEvent* then(TIME_TYPEDEF delayTime, std::function&lt;void()&gt; callback)</code></b><ul>
<li>Schedules a new event to occur after a specified delay from the current event's trigger time.</li>
<li><b>Parameters:</b><ul>
<li><code>delayTime</code>: The delay (in ticks) after the current event's <code>emitTick</code> when the new event should occur.</li>
<li><code>callback</code>: A function to execute for the new event.</li>
</ul>
</li>
<li><b>Returns:</b> A pointer to the newly created <code><a class="el" href="class_sim_event.html">SimEvent</a></code>.</li>
</ul>
</li>
<li><b><code>void emit()</code></b><ul>
<li>Triggers the event by executing its callback function.</li>
</ul>
</li>
<li><b><code>TIME_TYPEDEF getEmitTick() const</code></b><ul>
<li>Retrieves the simulation tick at which the event will be triggered.</li>
<li><b>Returns:</b> The event's <code>emitTick</code> as a <code>TIME_TYPEDEF</code>.</li>
</ul>
</li>
</ul>
<h1><a class="anchor" id="autotoc_md11"></a>
Channel Class</h1>
<p>The <code><a class="el" href="class_channel.html" title="Represents a communication channel between devices.">Channel</a></code> class simulates a communication channel in the local network, supporting message transmission and device listening mechanisms. It emulates real-world wireless local network characteristics, including:</p>
<ol type="1">
<li><b><a class="el" href="class_message.html">Message</a> Broadcast</b>: When a device sends a message to the channel, all devices listening to the channel will receive the message.</li>
<li><b><a class="el" href="class_message.html">Message</a> Collision</b>: If multiple devices send messages simultaneously, the messages will collide, resulting in a garbled signal that cannot be interpreted.</li>
</ol>
<h2><a class="anchor" id="autotoc_md12"></a>
Attributes</h2>
<ul>
<li><b><code>userNum</code></b> (<code>uint8_t</code>): Tracks the number of devices currently sending messages to the channel.</li>
<li><b><code>mixed</code></b> (<code>bool</code>): Indicates whether signal interference has occurred on the channel.</li>
<li><b><code>msg</code></b> (<code>const Message*</code>): A pointer to the message currently being transmitted on the channel.</li>
<li><b><code>listeners</code></b> (<code>std::list&lt;Device*&gt;</code>): A list of devices currently listening to the channel.</li>
</ul>
<h2><a class="anchor" id="autotoc_md13"></a>
Methods</h2>
<h3><a class="anchor" id="autotoc_md14"></a>
Constructor</h3>
<ul>
<li><b><code>explicit <a class="el" href="class_channel.html" title="Represents a communication channel between devices.">Channel()</a></code></b><ul>
<li>Initializes a <code><a class="el" href="class_channel.html" title="Represents a communication channel between devices.">Channel</a></code> object with no users (<code>userNum = 0</code>), no signal interference (<code>mixed = false</code>), and no active message.</li>
</ul>
</li>
</ul>
<h3><a class="anchor" id="autotoc_md15"></a>
Public Methods</h3>
<ul>
<li><b><code>void occupy(const Message* msg)</code></b><ul>
<li>Occupies the channel with a message for transmission.</li>
<li><b>Parameters:</b><ul>
<li><code>msg</code>: A pointer to the <code><a class="el" href="class_message.html">Message</a></code> to be transmitted.</li>
</ul>
</li>
</ul>
</li>
<li><b><code>void release()</code></b><ul>
<li>Releases the channel, making it available for new transmissions.</li>
</ul>
</li>
<li><b><code>void addListener(Device* d)</code></b><ul>
<li>Adds a device to the channel's list of listeners.</li>
<li><b>Parameters:</b><ul>
<li><code>d</code>: A pointer to the <code><a class="el" href="class_device.html">Device</a></code> to be added as a listener.</li>
</ul>
</li>
</ul>
</li>
<li><b><code>void removeListener(Device* d)</code></b><ul>
<li>Removes a device from the channel's list of listeners.</li>
<li><b>Parameters:</b><ul>
<li><code>d</code>: A pointer to the <code><a class="el" href="class_device.html">Device</a></code> to be removed.</li>
</ul>
</li>
</ul>
</li>
<li><b><code>bool isBusy() const</code></b><ul>
<li>Checks if the channel is currently occupied.</li>
<li><b>Returns:</b> <code>true</code> if the channel is occupied, <code>false</code> otherwise.</li>
</ul>
</li>
<li><b><code>bool isMixed() const</code></b><ul>
<li>Checks if signal interference has occurred on the channel.</li>
<li><b>Returns:</b> <code>true</code> if interference is present, <code>false</code> otherwise.</li>
</ul>
</li>
<li><b><code>const Message* getMsg() const</code></b><ul>
<li>Retrieves the message currently being transmitted on the channel.</li>
<li><b>Returns:</b> A pointer to the <code><a class="el" href="class_message.html">Message</a></code>.</li>
</ul>
</li>
<li><b><code>std::list&lt;Device*&gt; getListeners() const</code></b><ul>
<li>Retrieves the list of devices currently listening to the channel.</li>
<li><b>Returns:</b> A list of pointers to <code><a class="el" href="class_device.html">Device</a></code> objects.</li>
</ul>
</li>
<li><b><code>void error(std::string s)</code></b><ul>
<li>Throws a runtime error with a specified message.</li>
<li><b>Parameters:</b><ul>
<li><code>s</code>: A string containing the error message.</li>
</ul>
</li>
</ul>
</li>
</ul>
<h1><a class="anchor" id="autotoc_md16"></a>
Device Class</h1>
<p>The <code><a class="el" href="class_device.html">Device</a></code> class represents a physical device in the simulated network. It can send and receive messages, listen to channels, and manage its busy or waiting states.</p>
<h2><a class="anchor" id="autotoc_md17"></a>
Attributes</h2>
<ul>
<li><b><code>addr</code></b> (<code>ADDR_TYPEDEF</code>): The address of the device.</li>
<li><b><code>en</code></b> (<code>Environment*</code>): A pointer to the environment where the device operates.</li>
<li><b><code>txDelay</code></b> (<code>TIME_TYPEDEF</code>): The time delay required for the device to transmit a message.</li>
<li><b><code>busy</code></b> (<code>bool</code>): Indicates whether the device is currently busy sending messages.</li>
<li><b><code>waiting</code></b> (<code>bool</code>): Indicates whether the device is in a waiting state to access a channel.</li>
<li><b><code>onBusyChanged</code></b> (<code>std::function&lt;void(bool)&gt;</code>): A callback function triggered when the device's busy state changes.</li>
<li><b><code>onWaitingChanged</code></b> (<code>std::function&lt;void(bool)&gt;</code>): A callback function triggered when the device's waiting state changes.</li>
<li><b><code>listeningIndex</code></b> (<code>CHANNEL_INDEX_TYPEDEF</code>): The index of the channel the device is currently listening to.</li>
<li><b><code>logEnable</code></b> (<code>bool</code>): Controls whether the device's actions are logged.</li>
<li><b><code>msgQueue</code></b> (<code>std::queue&lt;std::tuple&lt;std::string, CHANNEL_INDEX_TYPEDEF, ADDR_TYPEDEF&gt;&gt;</code>): A queue storing messages to be sent, with each message containing a payload, target channel, and target address.</li>
</ul>
<h2><a class="anchor" id="autotoc_md18"></a>
Methods</h2>
<h3><a class="anchor" id="autotoc_md19"></a>
Constructor</h3>
<ul>
<li><b><code>explicit <a class="el" href="class_device.html">Device(ADDR_TYPEDEF addr, Environment* en)</a></code></b><ul>
<li>Initializes a <code><a class="el" href="class_device.html">Device</a></code> object with a specific address and environment.</li>
<li><b>Parameters:</b><ul>
<li><code>addr</code>: The address of the device.</li>
<li><code>en</code>: A pointer to the <code><a class="el" href="class_environment.html">Environment</a></code> where the device operates.</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3><a class="anchor" id="autotoc_md20"></a>
Protected Methods</h3>
<ul>
<li><b><code>void send(const std::string&amp; payload, CHANNEL_INDEX_TYPEDEF channelIndex, ADDR_TYPEDEF target)</code></b><ul>
<li>Enqueues a message to be sent.</li>
<li><b>Parameters:</b><ul>
<li><code>payload</code>: The message content.</li>
<li><code>channelIndex</code>: The target channel index.</li>
<li><code>target</code>: The target address.</li>
</ul>
</li>
</ul>
</li>
<li><b><code>void log(const std::string&amp; log)</code></b><ul>
<li>Logs the specified message if logging is enabled.</li>
<li><b>Parameters:</b><ul>
<li><code>log</code>: The message to log.</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3><a class="anchor" id="autotoc_md21"></a>
Public Methods</h3>
<ul>
<li><b><code>void recieve(const Message* msg, CHANNEL_INDEX_TYPEDEF channelIndex)</code></b><ul>
<li>Handles receiving a message on a specific channel.</li>
<li><b>Parameters:</b><ul>
<li><code>msg</code>: A pointer to the received <code><a class="el" href="class_message.html">Message</a></code>.</li>
<li><code>channelIndex</code>: The index of the channel where the message was received.</li>
</ul>
</li>
</ul>
</li>
<li><b><code>ADDR_TYPEDEF getAddr() const</code></b><ul>
<li>Retrieves the device's address.</li>
<li><b>Returns:</b> The device's <code>ADDR_TYPEDEF</code>.</li>
</ul>
</li>
<li><b><code>void listenTo(CHANNEL_INDEX_TYPEDEF channelIndex)</code></b><ul>
<li>Sets the device to listen to a specific channel.</li>
<li><b>Parameters:</b><ul>
<li><code>channelIndex</code>: The index of the channel to listen to.</li>
</ul>
</li>
</ul>
</li>
<li><b><code>void setBusy(bool v)</code></b><ul>
<li>Updates the device's busy state and triggers the <code>onBusyChanged</code> callback if defined.</li>
<li><b>Parameters:</b><ul>
<li><code>v</code>: The new busy state (<code>true</code> or <code>false</code>).</li>
</ul>
</li>
</ul>
</li>
<li><b><code>void setWaiting(bool v)</code></b><ul>
<li>Updates the device's waiting state and triggers the <code>onWaitingChanged</code> callback if defined.</li>
<li><b>Parameters:</b><ul>
<li><code>v</code>: The new waiting state (<code>true</code> or <code>false</code>).</li>
</ul>
</li>
</ul>
</li>
<li><b><code>void setOnBusyChanged(std::function&lt;void(bool)&gt; callback)</code></b><ul>
<li>Sets the callback function for busy state changes.</li>
<li><b>Parameters:</b><ul>
<li><code>callback</code>: A function to execute when the busy state changes.</li>
</ul>
</li>
</ul>
</li>
<li><b><code>void setOnWaitingChanged(std::function&lt;void(bool)&gt; callback)</code></b><ul>
<li>Sets the callback function for waiting state changes.</li>
<li><b>Parameters:</b><ul>
<li><code>callback</code>: A function to execute when the waiting state changes.</li>
</ul>
</li>
</ul>
</li>
<li><b><code>void setLogEnable(bool v)</code></b><ul>
<li>Enables or disables logging for the device.</li>
<li><b>Parameters:</b><ul>
<li><code>v</code>: <code>true</code> to enable logging, <code>false</code> to disable.</li>
</ul>
</li>
</ul>
</li>
<li><b><code>void error(std::string s)</code></b><ul>
<li>Throws a runtime error with the specified message.</li>
<li><b>Parameters:</b><ul>
<li><code>s</code>: A string containing the error message.</li>
</ul>
</li>
</ul>
</li>
</ul>
<h1><a class="anchor" id="autotoc_md22"></a>
ProtocolDevice Class</h1>
<p>The <code><a class="el" href="class_protocol_device.html">ProtocolDevice</a></code> class extends the <code><a class="el" href="class_device.html">Device</a></code> class and provides functionality for handling protocol-specific communication with other devices. It supports message sending, receiving, and callback management.</p>
<h2><a class="anchor" id="autotoc_md23"></a>
Attributes</h2>
<ul>
<li><b><code>callbacks</code></b> (<code>std::unordered_map&lt;MsgType, std::function&lt;void(ADDR_TYPEDEF, const std::string&amp;)&gt;&gt;</code>): A map of registered callbacks for specific message types.</li>
<li><b><code>onceCallbacks</code></b> (<code>std::unordered_map&lt;MsgType, std::function&lt;void(ADDR_TYPEDEF, const std::string&amp;)&gt;&gt;</code>): A map of one-time callbacks for specific message types.</li>
</ul>
<h2><a class="anchor" id="autotoc_md24"></a>
Methods</h2>
<h3><a class="anchor" id="autotoc_md25"></a>
Constructor</h3>
<ul>
<li><b><code>explicit <a class="el" href="class_protocol_device.html">ProtocolDevice(ADDR_TYPEDEF addr, Environment* en)</a></code></b><ul>
<li>Initializes the <code><a class="el" href="class_protocol_device.html">ProtocolDevice</a></code> object with the provided address and environment.</li>
<li><b>Parameters:</b><ul>
<li><code>addr</code>: The address of the device.</li>
<li><code>en</code>: A pointer to the environment.</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3><a class="anchor" id="autotoc_md26"></a>
Utility Methods</h3>
<ul>
<li><b><code>std::string formatKeyStr(const std::string&amp; key)</code></b><ul>
<li>Formats the given key string to a specific length, adding 'x' at the beginning or truncating if necessary.</li>
<li><b>Parameters:</b><ul>
<li><code>key</code>: The key string to format.</li>
</ul>
</li>
<li><b>Returns:</b> A formatted key string.</li>
</ul>
</li>
<li><b><code>std::string MsgTypeToHexString(MsgType num)</code></b><ul>
<li>Converts a <code>MsgType</code> value to its hexadecimal string representation.</li>
<li><b>Parameters:</b><ul>
<li><code>num</code>: The message type to convert.</li>
</ul>
</li>
<li><b>Returns:</b> A hexadecimal string representing the message type.</li>
</ul>
</li>
<li><b><code>MsgType hexStringToMsgType(const std::string&amp; hexStr)</code></b><ul>
<li>Converts a hexadecimal string to a <code>MsgType</code> value.</li>
<li><b>Parameters:</b><ul>
<li><code>hexStr</code>: The hexadecimal string to convert.</li>
</ul>
</li>
<li><b>Returns:</b> The corresponding <code>MsgType</code> value.</li>
</ul>
</li>
</ul>
<h3><a class="anchor" id="autotoc_md27"></a>
Sending Messages</h3>
<ul>
<li><b><code>void send(MsgType type, const std::string payload, CHANNEL_INDEX_TYPEDEF channelIndex, ADDR_TYPEDEF target)</code></b><ul>
<li>Sends a message with a <code>MsgType</code> and payload to a specific target.</li>
<li><b>Parameters:</b><ul>
<li><code>type</code>: The message type.</li>
<li><code>payload</code>: The message content.</li>
<li><code>channelIndex</code>: The target channel.</li>
<li><code>target</code>: The target address.</li>
</ul>
</li>
</ul>
</li>
<li><b><code>void send(MsgType type, CHANNEL_INDEX_TYPEDEF channelIndex, ADDR_TYPEDEF target)</code></b><ul>
<li>Sends a message with a <code>MsgType</code> to a specific target without a payload.</li>
<li><b>Parameters:</b><ul>
<li><code>type</code>: The message type.</li>
<li><code>channelIndex</code>: The target channel.</li>
<li><code>target</code>: The target address.</li>
</ul>
</li>
</ul>
</li>
<li><b><code>void send(MsgType type, const std::string payload, CHANNEL_INDEX_TYPEDEF channelIndex, ADDR_TYPEDEF target, std::function&lt;void(ADDR_TYPEDEF, const std::string&amp;)&gt; callback)</code></b><ul>
<li>Sends a message with a <code>MsgType</code> and payload to a specific target and registers a one-time callback for the response.</li>
<li><b>Parameters:</b><ul>
<li><code>type</code>: The message type.</li>
<li><code>payload</code>: The message content.</li>
<li><code>channelIndex</code>: The target channel.</li>
<li><code>target</code>: The target address.</li>
<li><code>callback</code>: A callback function to execute when a response is received.</li>
</ul>
</li>
</ul>
</li>
<li><b><code>void send(MsgType type, CHANNEL_INDEX_TYPEDEF channelIndex, ADDR_TYPEDEF target, std::function&lt;void(ADDR_TYPEDEF, const std::string&amp;)&gt; callback)</code></b><ul>
<li>Sends a message with a <code>MsgType</code> to a specific target and registers a one-time callback for the response.</li>
<li><b>Parameters:</b><ul>
<li><code>type</code>: The message type.</li>
<li><code>channelIndex</code>: The target channel.</li>
<li><code>target</code>: The target address.</li>
<li><code>callback</code>: A callback function to execute when a response is received.</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3><a class="anchor" id="autotoc_md28"></a>
Callback Management</h3>
<ul>
<li><b><code>void on(MsgType type, std::function&lt;void(ADDR_TYPEDEF, const std::string&amp;)&gt; callback)</code></b><ul>
<li>Registers a callback function to be executed when a message of the specified type is received.</li>
<li><b>Parameters:</b><ul>
<li><code>type</code>: The message type.</li>
<li><code>callback</code>: The callback function to execute.</li>
</ul>
</li>
</ul>
</li>
<li><b><code>void once(MsgType type, std::function&lt;void(ADDR_TYPEDEF, const std::string&amp;)&gt; callback)</code></b><ul>
<li>Registers a one-time callback function to be executed once when a message of the specified type is received.</li>
<li><b>Parameters:</b><ul>
<li><code>type</code>: The message type.</li>
<li><code>callback</code>: The callback function to execute.</li>
</ul>
</li>
</ul>
</li>
<li><b><code>void msgHandler(ADDR_TYPEDEF senderAddr, MsgType type, const std::string&amp; payload)</code></b><ul>
<li>Handles the received message by executing the appropriate callback.</li>
<li>If the message has a one-time callback, it is executed and removed from the <code>onceCallbacks</code>.</li>
<li><b>Parameters:</b><ul>
<li><code>senderAddr</code>: The address of the sender.</li>
<li><code>type</code>: The message type.</li>
<li><code>payload</code>: The message content.</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3><a class="anchor" id="autotoc_md29"></a>
Receiving Messages</h3>
<ul>
<li><b><code>void recieve(const Message* msg, CHANNEL_INDEX_TYPEDEF channelIndex) override</code></b><ul>
<li>Receives a message and processes it if the message's target is the current device.</li>
<li><b>Parameters:</b><ul>
<li><code>msg</code>: The message to receive.</li>
<li><code>channelIndex</code>: The channel index the message was received on.</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3><a class="anchor" id="autotoc_md30"></a>
Logging</h3>
<ul>
<li><b><code>void log(const std::string&amp; who, const std::string&amp; log)</code></b><ul>
<li>Logs a message with a specific prefix indicating the origin of the message.</li>
<li><b>Parameters:</b><ul>
<li><code>who</code>: The source of the log (e.g., "ProtocolDevice").</li>
<li><code>log</code>: The message content to log.</li>
</ul>
</li>
</ul>
</li>
</ul>
<h1><a class="anchor" id="autotoc_md31"></a>
Server Class</h1>
<p>The <code><a class="el" href="class_server.html">Server</a></code> class extends the <code><a class="el" href="class_protocol_device.html">ProtocolDevice</a></code> class to manage and coordinate <code><a class="el" href="struct_robot_data.html">RobotData</a></code> and <code><a class="el" href="struct_station_data.html">StationData</a></code>. It provides functionalities to handle robot and station information, login key management, and channel listening.</p>
<h2><a class="anchor" id="autotoc_md32"></a>
Attributes</h2>
<ul>
<li><b><code>robotsInfo</code></b> (<code>std::unordered_map&lt;ADDR_TYPEDEF, RobotData*&gt;</code>): A mapping of robot addresses to their corresponding <code><a class="el" href="struct_robot_data.html">RobotData</a></code> objects.</li>
<li><b><code>stationsInfo</code></b> (<code>std::unordered_map&lt;ADDR_TYPEDEF, StationData*&gt;</code>): A mapping of station addresses to their corresponding <code><a class="el" href="struct_station_data.html">StationData</a></code> objects.</li>
<li><b><code>robotLoginKey</code></b> (<code>std::string</code>): The formatted key for robot login.</li>
<li><b><code>stationLoginKey</code></b> (<code>std::string</code>): The formatted key for station login.</li>
</ul>
<h2><a class="anchor" id="autotoc_md33"></a>
Methods</h2>
<h3><a class="anchor" id="autotoc_md34"></a>
Constructor</h3>
<ul>
<li><b><code>explicit <a class="el" href="class_server.html">Server(ADDR_TYPEDEF addr, Environment* en)</a></code></b><ul>
<li>Initializes the <code><a class="el" href="class_server.html">Server</a></code> object with a specific address and environment.</li>
<li><b>Parameters:</b><ul>
<li><code>addr</code>: The server's address.</li>
<li><code>en</code>: A pointer to the <code><a class="el" href="class_environment.html">Environment</a></code>.</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3><a class="anchor" id="autotoc_md35"></a>
Public Methods</h3>
<ul>
<li><b><code>bool isRobot(ADDR_TYPEDEF addr)</code></b><ul>
<li>Checks if a given address belongs to a robot.</li>
<li><b>Parameters:</b><ul>
<li><code>addr</code>: The address to check.</li>
</ul>
</li>
<li><b>Returns:</b> <code>true</code> if the address belongs to a robot, <code>false</code> otherwise.</li>
</ul>
</li>
<li><b><code>bool isStation(ADDR_TYPEDEF addr)</code></b><ul>
<li>Checks if a given address belongs to a station.</li>
<li><b>Parameters:</b><ul>
<li><code>addr</code>: The address to check.</li>
</ul>
</li>
<li><b>Returns:</b> <code>true</code> if the address belongs to a station, <code>false</code> otherwise.</li>
</ul>
</li>
<li><b><code>StationData* getFreeStation()</code></b><ul>
<li>Retrieves a pointer to a free station.</li>
<li><b>Returns:</b> A pointer to a <code><a class="el" href="struct_station_data.html">StationData</a></code> object, or <code>nullptr</code> if no free station is available.</li>
</ul>
</li>
<li><b><code>void setStationStatus(ADDR_TYPEDEF addr, bool free)</code></b><ul>
<li>Updates the status of a station (free or busy).</li>
<li><b>Parameters:</b><ul>
<li><code>addr</code>: The station address.</li>
<li><code>free</code>: The new status (<code>true</code> for free, <code>false</code> for busy).</li>
</ul>
</li>
</ul>
</li>
<li><b><code>void setRobotLoginKey(const std::string&amp; key)</code></b><ul>
<li>Sets the robot login key.</li>
<li><b>Parameters:</b><ul>
<li><code>key</code>: The login key string.</li>
</ul>
</li>
</ul>
</li>
<li><b><code>void setStationLoginKey(const std::string&amp; key)</code></b><ul>
<li>Sets the station login key.</li>
<li><b>Parameters:</b><ul>
<li><code>key</code>: The login key string.</li>
</ul>
</li>
</ul>
</li>
<li><b><code>void addRobotAddr(ADDR_TYPEDEF addr)</code></b><ul>
<li>Adds a robot address to the <code>robotsInfo</code> map.</li>
<li><b>Parameters:</b><ul>
<li><code>addr</code>: The robot address.</li>
</ul>
</li>
</ul>
</li>
<li><b><code>void addStationAddr(ADDR_TYPEDEF addr)</code></b><ul>
<li>Adds a station address to the <code>stationsInfo</code> map.</li>
<li><b>Parameters:</b><ul>
<li><code>addr</code>: The station address.</li>
</ul>
</li>
</ul>
</li>
<li><b><code>void listenTo(CHANNEL_INDEX_TYPEDEF channelIndex)</code></b><ul>
<li>Listens to a specific channel and logs the action.</li>
<li><b>Parameters:</b><ul>
<li><code>channelIndex</code>: The index of the channel to listen to.</li>
</ul>
</li>
</ul>
</li>
<li><b><code>void log(const std::string&amp; log)</code></b><ul>
<li>Logs a message with the prefix "Server."</li>
<li><b>Parameters:</b><ul>
<li><code>log</code>: The message to log.</li>
</ul>
</li>
</ul>
</li>
</ul>
<h1><a class="anchor" id="autotoc_md36"></a>
Robot Class</h1>
<p>The <code><a class="el" href="class_robot.html">Robot</a></code> class extends the <code><a class="el" href="class_protocol_device.html">ProtocolDevice</a></code> class and represents a robotic device that can interact with a server and charging stations. It handles communication, navigation, charging, and login operations.</p>
<h2><a class="anchor" id="autotoc_md37"></a>
Attributes</h2>
<ul>
<li><b><code>needCharging</code></b> (<code>bool</code>): Indicates if the robot requires charging.</li>
<li><b><code>loginSuccess</code></b> (<code>bool</code>): Indicates if the robot has successfully logged in.</li>
<li><b><code>power</code></b> (<code>POWER_TYPEDEF</code>): The robot's current power level.</li>
<li><b><code>chargingStationAddr</code></b> (<code>ADDR_TYPEDEF</code>): The address of the charging station the robot is associated with.</li>
</ul>
<h2><a class="anchor" id="autotoc_md38"></a>
Methods</h2>
<h3><a class="anchor" id="autotoc_md39"></a>
Constructor</h3>
<ul>
<li><b><code>explicit <a class="el" href="class_robot.html">Robot(ADDR_TYPEDEF addr, Environment* en)</a></code></b><ul>
<li>Initializes the <code><a class="el" href="class_robot.html">Robot</a></code> object with a specific address and environment.</li>
<li><b>Parameters:</b><ul>
<li><code>addr</code>: The robot's address.</li>
<li><code>en</code>: A pointer to the <code><a class="el" href="class_environment.html">Environment</a></code>.</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3><a class="anchor" id="autotoc_md40"></a>
Public Methods</h3>
<ul>
<li><b><code>void listenTo(CHANNEL_INDEX_TYPEDEF channelIndex)</code></b><ul>
<li>Listens to a specific channel and logs the action.</li>
<li><b>Parameters:</b><ul>
<li><code>channelIndex</code>: The index of the channel to listen to.</li>
</ul>
</li>
</ul>
</li>
<li><b><code>void log(const std::string&amp; log)</code></b><ul>
<li>Logs a message with the prefix "Robot."</li>
<li><b>Parameters:</b><ul>
<li><code>log</code>: The message to log.</li>
</ul>
</li>
</ul>
</li>
<li><b><code>void gotoPosition(Position pos)</code></b><ul>
<li>Logs the action of moving to a specific position.</li>
<li><b>Parameters:</b><ul>
<li><code>pos</code>: The target position, with <code>x</code> and <code>y</code> coordinates.</li>
</ul>
</li>
</ul>
</li>
<li><b><code>void chagingUp()</code></b><ul>
<li>Increases the robot's power level by 20 units.</li>
</ul>
</li>
<li><b><code>POWER_TYPEDEF getPower() const</code></b><ul>
<li>Retrieves the robot's current power level.</li>
<li><b>Returns:</b> The power level as a <code>POWER_TYPEDEF</code>.</li>
</ul>
</li>
</ul>
<h3><a class="anchor" id="autotoc_md41"></a>
Communication with Server</h3>
<ul>
<li><b><code>void login(std::string loginKey)</code></b><ul>
<li>Logs in to the server using a specific key.</li>
<li><b>Parameters:</b><ul>
<li><code>loginKey</code>: The login key as a string.</li>
</ul>
</li>
</ul>
</li>
<li><b><code>void needCharge()</code></b><ul>
<li>Sends a request to the server indicating the need for charging.</li>
</ul>
</li>
<li><b><code>void sendToServer(MsgType type, const std::string payload)</code></b><ul>
<li>Sends a message with a payload to the server.</li>
<li><b>Parameters:</b><ul>
<li><code>type</code>: The message type.</li>
<li><code>payload</code>: The message payload.</li>
</ul>
</li>
</ul>
</li>
<li><b><code>void sendToServer(MsgType type)</code></b><ul>
<li>Sends a message to the server without a payload.</li>
<li><b>Parameters:</b><ul>
<li><code>type</code>: The message type.</li>
</ul>
</li>
</ul>
</li>
<li><b><code>void sendToServer(MsgType type, const std::string payload, std::function&lt;void(ADDR_TYPEDEF, const std::string&amp;)&gt; callback)</code></b><ul>
<li>Sends a message with a payload to the server and registers a callback for the response.</li>
<li><b>Parameters:</b><ul>
<li><code>type</code>: The message type.</li>
<li><code>payload</code>: The message payload.</li>
<li><code>callback</code>: A function to handle the server's response.</li>
</ul>
</li>
</ul>
</li>
<li><b><code>void sendToServer(MsgType type, std::function&lt;void(ADDR_TYPEDEF, const std::string&amp;)&gt; callback)</code></b><ul>
<li>Sends a message to the server without a payload and registers a callback for the response.</li>
<li><b>Parameters:</b><ul>
<li><code>type</code>: The message type.</li>
<li><code>callback</code>: A function to handle the server's response.</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3><a class="anchor" id="autotoc_md42"></a>
Communication with Station</h3>
<ul>
<li><b><code>void sendHandshakeToStation(std::string handShakey, ADDR_TYPEDEF stationAddr, CHANNEL_INDEX_TYPEDEF channelIndex)</code></b><ul>
<li>Sends a handshake message to a charging station.</li>
<li><b>Parameters:</b><ul>
<li><code>handShakey</code>: The handshake key.</li>
<li><code>stationAddr</code>: The address of the station.</li>
<li><code>channelIndex</code>: The channel index for communication.</li>
</ul>
</li>
</ul>
</li>
<li><b><code>void keepAliveWhenCharging()</code></b><ul>
<li>Sends periodic signals to indicate the robot is active while charging.</li>
</ul>
</li>
<li><b><code>void sendPowerFinish(ADDR_TYPEDEF stationAddr)</code></b><ul>
<li>Sends a message to the station indicating the charging process is complete.</li>
<li><b>Parameters:</b><ul>
<li><code>stationAddr</code>: The address of the charging station.</li>
</ul>
</li>
</ul>
</li>
</ul>
<h1><a class="anchor" id="autotoc_md43"></a>
Station Class</h1>
<p>The <code><a class="el" href="class_station.html">Station</a></code> class extends the <code><a class="el" href="class_protocol_device.html">ProtocolDevice</a></code> class and represents a station that can be used by robots for various operations, such as charging. It handles communication with the server, state management, and position updates.</p>
<h2><a class="anchor" id="autotoc_md44"></a>
Attributes</h2>
<ul>
<li><b><code>occupied</code></b> (<code>bool</code>): Indicates whether the station is occupied by a robot.</li>
<li><b><code>loginSuccess</code></b> (<code>bool</code>): A flag indicating whether the login process was successful.</li>
<li><b><code>x</code></b> (<code>POSITION_UNIT_TYPEDEF</code>): The x-coordinate of the station's position.</li>
<li><b><code>y</code></b> (<code>POSITION_UNIT_TYPEDEF</code>): The y-coordinate of the station's position.</li>
<li><b><code>chargingBotAddr</code></b> (<code>ADDR_TYPEDEF</code>): The address of the robot that is currently charging at the station.</li>
</ul>
<h2><a class="anchor" id="autotoc_md45"></a>
Methods</h2>
<h3><a class="anchor" id="autotoc_md46"></a>
Constructor</h3>
<ul>
<li><b><code>explicit <a class="el" href="class_station.html">Station(ADDR_TYPEDEF addr, Environment* en, POSITION_UNIT_TYPEDEF x, POSITION_UNIT_TYPEDEF y)</a></code></b><ul>
<li>Initializes the <code><a class="el" href="class_station.html">Station</a></code> object with the provided address, environment, and position.</li>
<li><b>Parameters:</b><ul>
<li><code>addr</code>: The station's address.</li>
<li><code>en</code>: A pointer to the <code><a class="el" href="class_environment.html">Environment</a></code>.</li>
<li><code>x</code>: The x-coordinate of the station's position.</li>
<li><code>y</code>: The y-coordinate of the station's position.</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3><a class="anchor" id="autotoc_md47"></a>
Public Methods</h3>
<ul>
<li><b><code>void log(const std::string&amp; log)</code></b><ul>
<li>Logs a message with the prefix "Station."</li>
<li><b>Parameters:</b><ul>
<li><code>log</code>: The message to log.</li>
</ul>
</li>
</ul>
</li>
<li><b><code>void sendToServer(MsgType type, const std::string payload)</code></b><ul>
<li>Sends a message with a payload to the server.</li>
<li><b>Parameters:</b><ul>
<li><code>type</code>: The type of the message.</li>
<li><code>payload</code>: The message content.</li>
</ul>
</li>
</ul>
</li>
<li><b><code>void sendToServer(MsgType type)</code></b><ul>
<li>Sends a message to the server without a payload.</li>
<li><b>Parameters:</b><ul>
<li><code>type</code>: The type of the message.</li>
</ul>
</li>
</ul>
</li>
<li><b><code>void sendToServer(MsgType type, const std::string payload, std::function&lt;void(ADDR_TYPEDEF, const std::string&amp;)&gt; callback)</code></b><ul>
<li>Sends a message with a payload to the server and provides a callback for a response.</li>
<li><b>Parameters:</b><ul>
<li><code>type</code>: The type of the message.</li>
<li><code>payload</code>: The message content.</li>
<li><code>callback</code>: The callback function to handle the response.</li>
</ul>
</li>
</ul>
</li>
<li><b><code>void sendToServer(MsgType type, std::function&lt;void(ADDR_TYPEDEF, const std::string&amp;)&gt; callback)</code></b><ul>
<li>Sends a message to the server and provides a callback for a response.</li>
<li><b>Parameters:</b><ul>
<li><code>type</code>: The type of the message.</li>
<li><code>callback</code>: The callback function to handle the response.</li>
</ul>
</li>
</ul>
</li>
<li><b><code>void login(std::string loginKey)</code></b><ul>
<li>Logs the station into the server using the provided login key.</li>
<li><b>Parameters:</b><ul>
<li><code>loginKey</code>: The login key for authentication.</li>
</ul>
</li>
</ul>
</li>
<li><b><code>void updateFreeToServer(bool free)</code></b><ul>
<li>Updates the station's status (free or occupied) to the server.</li>
<li><b>Parameters:</b><ul>
<li><code>free</code>: <code>true</code> if the station is free, <code>false</code> if occupied.</li>
</ul>
</li>
</ul>
</li>
<li><b><code>void updatePositionToServer()</code></b><ul>
<li>Updates the station's position to the server.</li>
</ul>
</li>
<li><b><code>POSITION_UNIT_TYPEDEF getX()</code></b><ul>
<li>Returns the x-coordinate of the station's position.</li>
<li><b>Returns:</b> The x-coordinate of the station.</li>
</ul>
</li>
<li><b><code>POSITION_UNIT_TYPEDEF getY()</code></b><ul>
<li>Returns the y-coordinate of the station's position.</li>
<li><b>Returns:</b> The y-coordinate of the station.</li>
</ul>
</li>
<li><b><code>void setOccupied(bool v)</code></b><ul>
<li>Sets the station's occupancy status and updates its status to the server.</li>
<li><b>Parameters:</b><ul>
<li><code>v</code>: <code>true</code> to mark the station as occupied, <code>false</code> to mark it as free. </li>
</ul>
</li>
</ul>
</li>
</ul>
</div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.12.0 </li>
  </ul>
</div>
</body>
</html>
